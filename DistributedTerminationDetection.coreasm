CoreASM TerminationDetection

use Standard
use StandardPlugins
use Signature
use MathPlugin
use TimePlugin

// Set number of Machines and Computation
derived MaxMachines = 5
derived MaxComputations = 3

enum COLOUR = {black, white}
enum STATUS = {active, inactive}

universe MACHINE
universe COMPUTATION
universe TOKEN
universe Agents = {supervisorAgent, slaveAgent}

function colour: MACHINE * COMPUTATION -> COLOUR
function status: MACHINE * COMPUTATION -> STATUS
function machineID: MACHINE -> NUMBER
function machineByID: NUMBER -> MACHINE
function nextMachine: MACHINE -> MACHINE
function tokenComputation: TOKEN -> COMPUTATION
function tokenColour: TOKEN -> COLOUR
function tokenMachine: TOKEN -> MACHINE

init initRule

rule initRule = {
	numMachines := 0
	numComputations := 0
	supervisor := undef
	program(self) := @addMachines
}

/* ---------------------------------------
 	MACHINE RELATED INITIALIZATIONS
 */
 
rule addMachines = {
	// Create and initialize the states of the machines in the cluster
	if numMachines < MaxMachines then {
		seqblock
		extend MACHINE with m do {
			initializeMachine(m)
		}
		numMachines := numMachines + 1
		endseqblock
	}
	else {
		supervisor := machineByID(0)
		// Link the mechines in a circular fashion
		seqblock
		forall m in MACHINE do {
			seqblock
			if machineID(m) = (MaxMachines-1) then {
				nextMachine(m) := machineByID(0)
			}
			else {
				nextMachine(m) := machineByID(machineID(m)+1)
			}
			
			// print "Current Machine: " + machineID(m) + " Next Machine: " + machineID(nextMachine(m))
			endseqblock
		}
		
		// Next step is to initialize the computations on each machine
		program(self) := @addComputation
		endseqblock
	}
}

rule initializeMachine(m) = {
	machineID(m) := numMachines
	machineByID(numMachines) := m
}


/* ---------------------------------------
 	COMPUTATION RELATED INITIALIZATIONS
 */

rule addComputation = {
	// Add computations to the set COMPUTATION
	if numComputations < MaxComputations then {
		seqblock
		extend COMPUTATION with c do {
			initializeComputation(c)
		}
		numComputations := numComputations + 1
		endseqblock
	}
	else {
		program(self) := @addToken
	}
}

rule initializeComputation(c) = {
	forall m in MACHINE do {
		seqblock
		// Randomly assign machines status to computations
		if (randomvalue > 0.5) then {
			status(m, c) := active
		}
		else {
			status(m, c) := inactive
		}
		// Initialize the machine colours to white
		colour(m,c) := white
		print "Machine " + machineID(m) + ": Status: " + status(m,c) + " Colour: " + colour(m,c)
		endseqblock
	}
}

/* ---------------------------------------
 	TOKEN RELATED INITIALIZATIONS
 */
 
 rule addToken = {
 	seqblock
 	forall c in COMPUTATION do {
 		extend TOKEN with t do {
 			initializeToken(t, c)
 		}
 	}
 	program(self) := @initDetection
 	endseqblock
 }
 
 rule initializeToken(t, c) = {
 	 //seqblock
	 tokenComputation(t) := c
	 tokenColour(t) := black
	 tokenMachine(t) := machineByID(0)
	 //print "Token Machine: " + machineID(tokenMachine(t)) + " TokenColour: " + tokenColour(t)
	 //endseqblock
 }
 
 /* ---------------------------------------
 	BEGIN DETECTION ALGORITHM
 */
 
 rule initDetection = {
 	//program(supervisorAgent) := @supervisorRule
 	program(slaveAgent) := @slaveRule
 	program(self) := undef
 }
 
 
 rule slaveRule = {
 	print "HelloWorld"
 	forall t in TOKEN do {
 		/*
 		m := tokenMachine(t)
 		c := tokenComputation(t)
 		// Inactive machine holding token, pass it on
 		//if m != supervisor and status(m, c) = inactive then {
 		if (status(m, c) = inactive) then {
 			if colour(m, c) = black then {
 				tokenColour(t) := black
 				colour(m, c) := white // Reset the machine colour to white
 			}
 			seqblock
 			print "Token passed from Machine " + machineID(m) + " to Machine " + machineID(nextMachine(m))
 			tokenMachine(t) := nextMachine(m)
 			endseqblock
 		}
 		*/
 		

 		// Inactive machine holding token, pass it on
 		//if m != supervisor and status(m, c) = inactive then {
 		if (status(tokenMachine(t), tokenComputation(t)) = inactive) then {
 			if colour(tokenMachine(t), tokenComputation(t)) = black then {
 				tokenColour(t) := black
 				colour(tokenMachine(t), tokenComputation(t)) := white // Reset the machine colour to white
 			}
 			seqblock
 			print "Token passed from Machine " + machineID(tokenMachine(t)) + " to Machine " + machineID(nextMachine(tokenMachine(t)))
 			tokenMachine(t) := nextMachine(tokenMachine(t))
 			endseqblock
 		}
 	}
 }
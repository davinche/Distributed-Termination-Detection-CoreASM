CoreASM TerminationDetection

use Standard
use StandardPlugins
use Signature
use MathPlugin
use TimePlugin

// Set number of Machines and Computation
derived MaxMachines = 5
derived MaxComputations = 3
derived supervisor = machineByID(0)

enum COLOUR = {black, white}
enum STATUS = {active, inactive}
enum TOKENFORWARD = {idle, forward}

universe MACHINE
universe COMPUTATION
universe TOKEN
universe Agents = {supervisorAgent, slaveAgent, tokenControl, environment, observer}

function colour: MACHINE * COMPUTATION -> COLOUR
function status: MACHINE * COMPUTATION -> STATUS
function machineID: MACHINE -> NUMBER
function machineByID: NUMBER -> MACHINE
function nextMachine: MACHINE -> MACHINE
function computationID: COMPUTATION -> NUMBER
function tokenComputation: TOKEN -> COMPUTATION
function tokenColour: TOKEN -> COLOUR
function tokenMachine: TOKEN -> MACHINE
function tokenForwardSignal: TOKEN -> TOKENFORWARD

init initRule

rule initRule = {
	numMachines := 0
	numComputations := 0
	program(self) := @addMachines
}

/* ---------------------------------------
 	MACHINE RELATED INITIALIZATIONS
 */
 
rule addMachines = {
	// Create and initialize the states of the machines in the cluster
	if numMachines < MaxMachines then {
		extend MACHINE with m do {
			initializeMachine(m)
		}
	}
	else {
		// Link the machines in a circular fashion
		seqblock
		forall m in MACHINE do {
			if machineID(m) = (MaxMachines-1) then {
				nextMachine(m) := machineByID(0)
			}
			else {
				nextMachine(m) := machineByID(machineID(m)+1)
			}
		}
		
		// Next step is to initialize the computations on each machine
		program(self) := @addComputation
		endseqblock
	}
}

rule initializeMachine(m) = {
	seqblock
	machineID(m) := numMachines
	machineByID(numMachines) := m
	numMachines := numMachines + 1
	endseqblock
}


/* ---------------------------------------
 	COMPUTATION RELATED INITIALIZATIONS
 */

rule addComputation = {
	// Add computations to the set COMPUTATION
	if numComputations < MaxComputations then {
		extend COMPUTATION with c do {
			initializeComputation(c)
		}
	}
	else {
		program(self) := @addToken
	}
}

rule initializeComputation(c) = {
	
	seqblock
	computationID(c) := numComputations
	numComputations := numComputations + 1
	endseqblock
	
	forall m in MACHINE do {
		// Randomly assign machines status to computations
		if (randomvalue > 0.5) then {
			status(m, c) := active
		}
		else {
			status(m, c) := inactive
		}
		// Initialize the machine colours to white
		colour(m,c) := white
	}
}

/* ---------------------------------------
 	TOKEN RELATED INITIALIZATIONS
 */
 
 rule addToken = {
 	seqblock
 	forall c in COMPUTATION do {
 		extend TOKEN with t do {
 			initializeToken(t, c)
 		}
 	}
 	program(self) := @initDetection
 	endseqblock
 }
 
 rule initializeToken(t, c) = {
	 tokenComputation(t) := c
	 tokenColour(t) := black
	 tokenMachine(t) := supervisor
	 tokenForwardSignal(t) := idle
 }
 
 /* ---------------------------------------
 	BEGIN DETECTION ALGORITHM
 */
 
 rule initDetection = {
 	program(supervisorAgent) := @supervisorRule
 	program(slaveAgent) := @slaveRule
 	program(tokenControl) := @tokenRule
 	program(observer) := @observerRule
 	program(environment) := @environmentRule
 	seqblock
 	forall t in TOKEN do {
 		print "TOKEN MACHINE: " + machineID(tokenMachine(t)) + " TOKEN COMPUTATION: " + computationID(tokenComputation(t)) + " TOKEN COLOUR: " + tokenColour(t)
 	}
 	print ""
 	endseqblock
 	//program(self) := undef
 }
 
 rule supervisorRule = {
 	// Process the tokens held by the supervisor
 	forall t in TOKEN with (tokenMachine(t) = supervisor) do {
 		if status(supervisor, tokenComputation(t)) = inactive then {
 			// Black token detected, or supervisor is black... pass a new white token
 			if colour(supervisor, tokenComputation(t)) = black or tokenColour(t) = black then {
 				seqblock
 				tokenColour(t) := white
 				colour(supervisor, tokenComputation(t)) := white
 				tokenForwardSignal(t) := forward
 				endseqblock
 			}
 		}
 	}
 }
 
 rule slaveRule = {
 	forall t in TOKEN with (tokenMachine(t) != supervisor) do {
 		if status(tokenMachine(t), tokenComputation(t)) = inactive then {
 			if colour(tokenMachine(t), tokenComputation(t)) = black then {
 				seqblock
 				tokenColor(t) := black
 				colour(tokenMachine(t), tokenComputation(t)) := white
 				tokenForwardSignal(t) := forward
 				endseqblock
 			}
 			else {
 				tokenForwardSignal(t) := forward
 			}
 		}
 	}
 }
 
 rule observerRule = {
 	forall t in TOKEN do {
 		// Token held by machine processing...
		if tokenForwardSignal(t) = idle and status(tokenMachine(t), tokenComputation(t)) = active then {
			if tokenMachine(t) = supervisor then {
				print "SUPERVISOR: Processing for Computation " + computationID(tokenComputation(t))
			}
			else {
				print "Machine " + machineID(tokenMachine(t)) + " Processing for Computation " + computationID(tokenComputation(t))
			}
		}
		
		// Token determined to require forwarding
		if tokenForwardSignal(t) = forward then {
			if tokenMachine(t) = supervisor then {
				print "SUPERVISOR: Self is black or black token detected. Need to forward new white token for Computation " + computationID(tokenComputation(t))
			}
			else {
				if colour(tokenMachine(t), tokenComputation(t)) = black then {
					print "Machine " + machineID(tokenMachine(t)) + " is black. Need to forward a black token for Computation " + computationID(tokenComputation(t))
				}
				else {
					print "Machine " + machineID(tokenMachine(t)) + " need to forward the token for Computation " + computationID(tokenComputation(t))
				}
			}
		}
 	}
 }
 
 rule tokenRule = {
 	forall t in TOKEN do {
 		if tokenForwardSignal(t) = forward then {
 			tokenForwardSignal(t) := idle
 			tokenMachine(t) := nextMachine(tokenMachine(t))
 		}
 	}
 }
 
 
  rule environmentRule = {
 	forall m in MACHINE do {
 		forall c in COMPUTATION do {
 			// Loop through all active machines...
 			if status(m, c) = active then {
 				// 30% chance to send a message to a random machine
 				//if randomvalue <= 0.3 then {
 				//	sendMessage(m, randMachine(m), c)
 				//}
 				
 				// 50% chance of finishing job
 				if randomvalue <= 0.5 then {
 					status(m, c) := inactive
 				}
 			}
 		}
 	}
 }

 rule sendMessage(s, r, c) = {
 	seqblock
 		print "Machine " + machineID(s) + " requested Machine " + machineID(r) + " to process a job for Computation " + computationID(c)
 		colour(s, c) := black
 		status(r, c) := active
 		print "Machine " + machineID(r) + " is now ready to process a job for Computation " + computationID(c)
 	endseqblock
 }
 
 // Select a random machine (for sending a message)
 rule randMachine(curr) =
 	return r in
 		choose x in MACHINE with (machineID(x) != machineID(curr)) do
 			r := x